= Vim quick reference
:toc: left
:imagesdir: images
:stylesdir: C:\Users\echo\Documents\repos\vim-quick-ref\css
:stylesheet: material-blue.css
:doctype: article


== Super tips
* vimgrep.org for the manual
* q: or :ctrl-f - editable list of recent commands, select a command and press ENTER to issue
* helpgrep {word} - search the help
* :set foldmethod=indent - folds XML and HTML after pretty printing
* d/word Delete up to a word in normal mode

== Start Vim with a session

----
gvim -S ~/documents/repos/notes/Session.vim (for p53 computer)
gvim -S **/notes/session.vim
----

NOTE: Default Windows behavior is for filepaths/filenames to be case insensitive.

Applications often have their own equivalents.

== Directories

$HOME - the user directory
:echo $HOME

$MYVIMRC - location of the vimrc file used on initialization
:echo $MYVIMRC
:echo $VIMRUNTIME

$VIM - location of the Vim system directory
:echo $VIM

== Vim initialization

The files are searched in the following order and only the first one that is found is read.

.	$HOME/_vimrc
. $HOME/vimfiles/vimrc
. $VIM/_vimrc

Following the recommendation in the Help file, I have put my vimrc in $HOME/vimfiles.
That file contains the following text to redirects to repos/vimrc/vimrc:

----
source $HOME\Documents\repos\vimrc\vimrc
----

Then, the system vimrc file is read for initializations.  
The path of this file is shown with the ":version" command and is usually "$VIM/vimrc".
On my P53 computer this is: C:\Program Files (x86)\Vim\_vimrc

Then the plugin scripts are loaded.
All directories in the 'runtimepath' option are searched for the "plugin" sub-directory.
All files ending in ".vim" are sourced (in alphabetical order per directory).

My plugins plugged folder is here: C:\Users\echo\vimfiles\plugged

$HOME\vimfiles\plugged

This folder is explicitly called from the vimrc file with:

----
call plug#begin('$HOME/vimfiles/plugged')
----

After the plugins are loaded, the GUI initializations are performed.

Then the viminfo file is read.

Then windows are opened.

== Start Vim and then load a Session file:

. Winkey gvim (pwd is ~/echo/documents/repos/)
. so notes/Session.vim
. so **/notes/session.vim

The path is relative to the pwd if there is no file loaded and to the current buffer location if there is one loaded.

== Redirect the vimrc file to another location under Git control

In _vimrc located in $MYVIMRC, add this one line: 

== Start Vim with a different vimrc file:

. gvim
. so vimrc-config/vimrc-basic

The path is relative to the pwd if there is no file loaded and to the current buffer location if there is one loaded.

You can also open a different vimrc file and then source it with :so %

When you start gvim from Windows Run, it looks in the C: drive as the root path.
Therefore, to pass a filename, you have to add the path from C:

== Opening existing files

Navigate to the project directory.
Set it as the current working directory.
Then...

* :sf [file] - splits the current window and opens the file with a path relative to the current buffer.
* :vert sf [file] - vertically splits the current window and opens the file with a path relative to the current buffer.
* :tabf [file] - open a file with the path relative to the current buffer in a new tab.
* :tabe [file] - open file with the path relative to the present working directory in a new tab.
* :vert sb start typing filename and <TAB> - split the current window vertically and open the named buffer
* ctrl-w r - switch the contents of two buffer windows

== Open a new buffer for editing

* :e: - reload the current file so changes made to the vimrc are enacted for the file
* :enew - hide the buffer in the current window and replace it with a new empty buffer
* :enew! - hide the buffer in the current window, deleting any unsaved changes, and replace it with a new empty buffer
* :new - split the current window horizontally and open a new empty buffer
* :vert new - split the current window vertically and open a new empty buffer
* :badd - open a buffer without viewing it in the window so you can do an xref or conref to the file using autocomplete
* :ball - open all loaded buffers in their own horizontal window
* :vert ball - open all loaded buffers in their own vertical window
* :view <filename> - open the buffer as read-only
* :BD - closes a buffer while keeping the window open

== Buffers list

* :sb <TAB> - Shows list of buffers in the folder you can autocomplete
:buffers - shows list of buffers
:ls - shows list of buffers
:Buffers - fzf plugin shows list of buffers in friendlier format with preview

* %	- the buffer in the current window
* #	- the alternate buffer viewed with :b#
* a	- an active buffer: it is loaded and visible
* h	- a hidden buffer: It is loaded, but currently not displayed in a window |hidden-buffer|
* -	- a buffer with 'modifiable' off
* =	- a read-only buffer
* +	- a modified buffer

== Abbreviations
* :iab word1 word2 - Add an insert mode abbreviation - replace word1 with word2 
* :iuna word - Remove an insert mode abbreviation from the list
* :Bufferize iab - list current insert mode abbreviations in a buffer
* :Bufferize cab - list current command mode abbreviations in a buffer
* <space> - adds a space to a word


== Switch between buffers

* [b = switch to the next buffer in the rotation
* ]b = switch to the previous buffer in the rotation
* :bn = switch to the next buffer in the rotation
* :ls = list the open buffers
* :b12 = switch to buffer number 12
* :b <start typing buffer name>

With tpope/vim-unimpaired:

]a - next buffer
[b - previous buffer

== Find files

* <leader>f - use fzf fuzzy finder
* :edit <filepath>/<filename> - searches relative to the present working directory and opens the file; Do not need to have a buffer open.
* :edit **/<filename><TAB> - searches for files in the present working directory and its subdirectories; Do not need to have a buffer open.
* :find <filepath>/<filename> - searches relative to the directory of the current buffer (because 'set path=.') Must have a buffer open to do this.
* :find **/<filename><TAB> - searches for files in the directory of the current buffer and its subdirectories Must have a buffer open to do this.
* :e # - Toggle between current and previous file
* ctrl-^ - Toggle between current and previous file

== Close files
Vim will quit when you:

* Delete the last buffer
* Close the last window
* Close the last tab

.Buffers
* :w - write (save the buffer to disk)
* :bd - close the active buffer, prompting you if there are unwritten changes
* :bd! - close the active buffer and delete unwritten changes
* :e! - overwrite the open buffer with what is saved on the drive
* :10,25bd - close all buffers between 10 and 25
* :bd 3 5 - close buffers 3 and 5

.Windows
* :clo {count} - close the window without deleting the active buffer. Will not close the last window i.e. the application.
* :q - close the window without deleting the active buffer. Will close the last window i.e. The application but prompts you if there are unsaved buffers.

.Tabs
* :tabcl[ose] - close the tab

.Application
* :q - close the window without deleting the active buffer. Will close the last window i.e. The application but prompts you if there are unsaved buffers.
* :wq - write the buffer and close the window, ending the session if it is the last buffer.
* :qa - close all windows. Will also close the last window i.e. The application but prompts you if there are unsaved buffers.
* :qa! - close all windows. Will also close the last window i.e. The application and  including the last one  (
* :%bd - same as :qa
* :q! - force quit (close the window and if there are unsaved changes in the active buffer, don't prompt you and don't save them. Therefor the application without saving unsaved changes to any buffers)

== Screen elements

* buffer - in-memory representation of a file that may not actually be saved as a file yet
* window - a view into a buffer
* tab - a workspace that contains one or more windows with different window layouts
* tabline - the line at the top that contains tabs
* quickfix window - displays the quickfix list
* commandline - bottom area that allows you to send commands to Vim
* commandline window - displays an editable list of the previous commands
* statusline - shows information about the buffer

In other programs, a tab is a proxy for a document.

== Window size
:set lines=100
:set columns=200

== Navigate

=== Navigate within the line

f,t,F,T - using quick-scope plugin

=== Navigate within the screen with vim-sneak

Look at where you want to put the cursor and note the nearest two characters.

<leader>q first-letter second-letter (using vim-sneak plugin)

At each instance of those two characters, a code character appears in the text.
Type the character.

; to go to the nexxt match.

ctrl-o to go back to the start.

dzqt - delete to qt

=== Navigate within the screen with line numbers

* 10j - jumps down 10 lines remaining in the current column
* 10k - jumps up 10 lines remaining in the current column
* 10+ - jumps down 10 lines and places the cursor in the first column
* 10- - jumps up 10 lines and places the cursor in the first column
 
=== Navigate to positions off the screen

* :n - move by line (after looking at the statusline to see how many lines the document has)
* / or ? - search forward or backward
* 90% - jumps to the 90% line number
* Collapse the folds and locate the fold you need

=== Navigate files

* gf - open file whose filename is under the cursor
* gx - open the URL under the cursor in the default browser - must be a complete auto-underlined URL
* ^ - jump back to previous file after gf
* Ctrl-w f - open the file whose filename is under the cursor in a new window

To make gf work, you may need to change the path setting or change how you write the file.
Instead of `tasks.adoc` you may need to write `./admin/notes/tasks.adoc`.
Or the current working directory may need to be the directory that the current buffer is in.
Or, you may need to change the scope of the 'path' setting.

=== Navigate screen position

* H - The document remains in place and the current line jumps to the line number at the top of the window.
* M - The document remains in place and the current line jumps to the line number at the middle of the window.
* L - The document remains in place and the current line jumps to the line number at the bottom of the window.

* + - move cursor to start of next line without adding a new line
* - - move cursor to start of previous line without adding a new line

=== Scroll document

* ctrl-e - scroll downward in the document
* ctrl-y - scroll upward in the document
* zt - The cursor stays on the current line and the document scrolls so the line is now at the top of the window.
* zz - The cursor stays on the current line and the document scrolls so the line is now in the middle of the window.
* zb - The cursor stays on the current line and the document scrolls so the current line is now at the bottom of the window.
* z<ENTER> - same as zt

== Editing

Editing command structure:
<number><operator><([modifier]text object) or motion>

Motion commands operate from the current cursor position.
Text object commands operate on the whole object regardless of cursor position.
Use text object commands for editing whenever possible for greater efficiency.

=== Operators

* y
* c
* d
* > - indent right
* < - indent left
* = - autoindent
* gU - make uppercase
* gu - make lowercase
* g~ - swap case

=== Text objects

==== Plaintext text objects

* w - a word 
* s - a sentence
* p - a paragraph

==== Text object modifiers

* i - inner
* a - around

==== Programming language text objects

* "
* '
* `
* )
* ]
* }

==== Enhancements with wellle/targets.vim

Overrides Vim defaults to allow seeking to the next pair of target objects so you don't have to be inside the object.
Also, adds the following separators:

* , . ; : + - = ~ _ * # / | \ & $
* >
* <
* t (tab)

And adds the following modifiers:

* in( - inside the next set of parentheses
* il( - inside the previous set of parentheses


== Deleting to a word

In Normal mode:

d/hobbits - deletes up to the word hobbits
c/hobbits - deletes up to the word hobbits and enters Insert mode
v/hobbits - visually selects up to the word hobbits

== Joining lines

J - join two lines with a space
gj - join two lines with no space

== Change case

*  ~    - Changes the case of current character
*  guu  - Change current line from upper to lower.
*  gUU  - Change current LINE from lower to upper.
*  guw  - Change to end of current WORD from upper to lower.
*  guaw - Change all of current WORD to lower.
*  gUw  - Change to end of current WORD from lower to upper.
*  gUaw - Change all of current WORD to upper.
*  g~~  - Invert case to entire line
*  g~w  - Invert case to current WORD
*  guG  - Change to lowercase until the end of document.
*  gU)  - Change until end of sentence to upper case
*  gu}  - Change to end of paragraph to lower case
*  gU5j - Change 5 lines below to upper case
*  gu3k - Change 3 lines above to lower case

==== Markup language text objects

* t
* >

=== Motions

* + - move cursor to the first character of the next line
* - - move cursor to the first character of the previous line
* w - move cursor to start of next word
* W - move cursor to start of next WORD
* e - move cursor to end of next word
* b - move cursor to start of previous word
* ge - move cursor to end of previous word
* ) - move cursor to start of next sentence
* } - move cursor to start of next paragraph
* [[ - move cursor to start of next section

=== Other editing actions

* ctrl-w - Corrects typing error by deleting the previous word when in Insert mode.
* s - Delete character and enter Insert mode
* :%y - yank the entire file
* d/pattern - delete from the cursor forward to the start of the pattern
* d/pattern/e - delete from the cursor forward to the end of the pattern
* c/pattern - change from the cursor forward to the start of the pattern
* c/pattern/e - change from the cursor forward to the end of the pattern
* :m+10 - move the current line 10 lines down
* :.,+10m100 - move the range from the current line plus the next ten to line 100
* :.,+10m'a - move the range from the current line plus the next ten to the line with marker 'a'
//
* S or cc - deletes the entire line and enter insert mode to substitute text - very useful for deleting the next number of lines, such as 5S. Contrast with typing d5j that keeps in Normal mode.
* ea - append text to the end of the word
* 2s - substitute the next three characters in a word (useful when cw changes too many and r only replaces one) for example change Hoggit to Hobbit
* 20i- <Esc> - insert 20 hyphens

== Wrap lines

* :set wrap linebreak - soft wrap lines
* :set nowrap nolinebreak - don't soft-wrap lines
* :set wrap - turns on soft wrap
* :set linebreak - forces the soft wrapping at word boundaries instead of inside words
* :set tw=0 - stops automatic hard wrapping at a column
* :set formatoption-=t - use this if hardwrapping is automatic and can't figure it out

== Resize text

<leader><leader>+ +
<leader><leader>+ -

////
. Hold down and do not release the spacebar.
. Either:
* To make larger: Press and release the equals key (=), brief pause, then *quickly* press the equals key (=) again one or more times as needed.
* To make smaller: Press and release the equals key (=), brief pause, then *quickly* press the minus key (-) one or more times as needed.

. Release the spacebar.
////

Alternatively:

* :set guifont=*
* :set guifont=Roboto_Mono:h16

== Mapped function keys

* F1 = Opens the Vim help
* F2 = Toggles show/hide whitespace characters defined in listchars setting
* F3 = Remove trailing whitespace
* F4 = After a :g/pattern command, F3 copies the result to a new buffer
* F5 = Paste the date
* F6 = Paste the date and time
* F7 = Toggles spell check based on the spell file specified in the vimrc
* F8 = Toggles relative/standard line numbering
* F9 =
* F10 = Zoom vsplit window
* F11 = Unzoom vsplit window
* F12 = Implements ALEFix

== Spell check

]s - go to next error
[s - go to previous error

:SpellCheck - List spelling errors in quickfix list using plugin

zg - add word under cursor to dictionary.
zug - remove word under cursor to dictionary.
z= - get suggestion for misspelled word and select number to fix

== Automatic spelling correction with abbreviations

Use the vim-abolish/vim-correction plugins.
These use the abbreviations list to make the correction.

When you finish typing the incorrect word and hit the spacebar, it will automatically fix it.
Examples:

* wroking
* teh

To see a list of words:
:abbrev

== Switch characters

* <leader>c - character switch hobbit
* <leader>w - switch words
* <leader> right/left ENTER - :h move word one place

== Open a calendar

* :Calendar -view=month
* :Calendar -view=year
* :Calendar -view=year -split=vertical -width=27
* :IndentLinesToggle to remove vertical indent lines as F9 does not work in this plugin.

 Switch between views with < and > keys.

== Miscellaneous

* @: - repeat the last commandline command, followed by @@ for additional repeats
* :set cmdheight=n - Change height of commandline
* ctrl-c - Abort insert mode and abandon changes
* https://vimhelp.org/ - official help
* :vert h:<topic> - Open the Help in a vertical split
* :tab h<topic> - Open the Help in a tab to make it easier to read
* :set scb (scrollbind) on both windows to scroll two vertical splits together
* :set noscb on one window to stop scrolling two vertical splits together
* :r file1 - paste the contents of file1 at the current cursor position - great for templates
* :%s/$^\n// - removing blank lines
* :%s/$^\n\n// - removing two blank lines
* :%s/$^\n\n/\r/ - replacing two blank lines with one blank line
* :set all - show all options. ! puts each on its own line, including plugins being used
* :set[!] - show all options that differ from their default value. ! puts each on its own line.
* :set <option>? - show the value of the option
* :set <option>=10
* :[range]ce[nter] [column width] - center the lines
* :[range]sort - sorts alphabetically
* g ctrl-g - puts a word count in the statusline
* ctrl-l - redraw the screen
* dw - delete the whitespace in front of the cursor up to the next word.
* gi - switch to Insert mode and return to the last edit
* ga - show the character code for the character under the cursor (decimal, hexadecimal, octal, digraph)

== Rename a file using DOS command

:!rename % file2
:!rename file1 file2

== Removing ^M
:%s/<ctrl-v><ctrl-m>/\r/g

== Run a macro

* qN - start a macro recording and store in N
* q - stop macro recording
* @N - play back macro stored in N
* @@@ - repeat the previously played macro
* 10@N - play back the macro stored in N 10 times

qaq to empty register a before storing a macro in register a.

To edit macro a on the commandline:

. :let @a='<ctrl-r><ctrl-r>a (do not press ENTER).
. Make the edit.
. Add the closing '.
. Press ENTER.

Store macros you want to keep in a buffer.
Paste them in with "ap (for buffer a).
You can also edit them in the buffer.
To put the line back into the a register, select the line then "ayy

== Change current working directory

* :cd <relative path> - change current working directory for the session
* :lcd <relative path> - change current working directory for the window
* :tcd <relative path> - change current working directory for the tab

== Open a tab

<leader>a

== Substitute in one file

* :%s/find/replace/gc
* :3,45s/find/replace/gc

* % = global in the document (not just the line - as it is a line editor)
* s = substitute
* g = global in the line (so it will find multiple instances on a line)
* c = ask for confirmation before making each substitution

Does not create a quicklist that you can view.
It just makes the changes in the file.

You can also use " or | for the pattern delimiter instead of /.
This avoids having to escape the / in filepaths.

== Substitute across files with arglist

* :args **/*.filetype
* :args (to verify the list)
* :argdo %s/word/replace/g

== Change the colorscheme

* :colorscheme <Enter> = names the current colorscheme
* :colorscheme <name> <Enter> = switches to the colorscheme
* :colorscheme <start typing the name> <TAB> = autocomplete
* :colorscheme <tab> = rotate through available colorschemes

NOTE: I modified vimfiles/colors/gruvbox.vim to make the headings red and saved it to my vim-config folder.

The color of the folds is set in the vimrc with:
highlight Folded guifg=goldenrod2

== Navigate the quickfix list
:help vim-qf

* cn - next
* cp - previously
* cf - first
* cl - last
* ccn - go to number n

With tpope vim-unimpaired

* ]q - next 
* [q - previous
* [Q - first
* ]Q - last

To view older or newer quickfix lists:

* :colder
* :cnewer

You can operate on the quickfix list:

:cdo s/foo/bar/ | update
:cfdo - close any buffers that open

romainl/vim-qf plugin enhances behavior, such as opening the quickfix window automatically after a vimgrep, switching to absolute numbering, etc.

To filter the list:

:Keep {word}
:Reject {word}
:Restore

bfrg/vim-qf-preview plugin allows a preview of the item in the quickfix list:
To use this, first select the quickfix window (otherwise the 'p' keystroke will paste the contents of the default register.

* p (with the cursor in the quickfix list) - open preview
* ctrl-k, ctrl-j - Scroll up/down one text line in the preview
* Shift-Home, Shift-End - Scroll to first/last line of displayed buffer in the preview
* r - Scroll back to error line corresponding to the quickfix list item ("reset")
* q, Ctrl-c - Close the popup window: 

== Capture any list in a buffers
Use the Bufferize plugin with:

:Bufferize {command}

For example:

:Bufferize ab - lists the current abbreviations list

== Preview window

A preview window can be opened with:

:ped - open preview window
:pc - close preview window
:psearch /pattern/ - shows found match in preview window

If you want the preview window to open as a popup:

:previewpopup
:previewpopup=height:20,width:40

== Xterm colors for vimrc

https://codeyarns.com/tech/2011-07-29-vim-chart-of-color-names.html


== Insert completion

https://vim.fandom.com/wiki/Omni_completion

Vim has many options for completion that pull words/terms/filenames from different places.

=== Built-in keyword completion

The basic completion is keyword completion, triggered with ctrl-n or ctrl-p.
ctrl-n looks forward in the file for keywords and ctrl-p looks backward in the file.
It pulls words from, all of the buffers loaded in the Vim instance and saved.
It will not work on a buffer that has not been saved.

IMPORTANT: If the default word insert completion is not working, it is probably because you didn't set the present working directory to the directory with your files.
This catches me out a lot, so don't forget.

To activate, in insert mode, start typing the term, then use crtl-n or ctrl-p.
If there is more than one option, a list appears. 
Use ctrl-n or ctrl-p repeatedly to cycle through the options.

To simplify this, I have mapped ctrl-n to the TAB key so I can just press TAB.
With this mapping, hit TAB and keep hitting TAB to select the option you want, then hit ENTER.

You need to set where Vim will look for the completion terms with set completion,
My current options are:

set complete+=.,w,b,u,i

The default is ".,w,b,u,t,i", which means to scan:

* the current buffer
* buffers in other windows
* other loaded buffers
* unloaded buffers
* tags
* included files

NOTE: You have to use the syntax +=

=== Filename completion

Some of the other completion types are: 

* ctrl-x ctrl-f to complete a filename (insert filename completion)
* ctrl-x ctrl-l to complete a line higher up in the file (insert line completion)

I have mapped filename completion in the vimrc to <leader><Tab> to reduce keystrokes.

To insert-complete filenames with extensions, you need to add the . character to the definition of a word.
To insert-complete filenames with hyphens you need to add the - character to the definition of a word.

Filename completion is harder to achieve.
An alternative is to create a text file list of filenames with:
$dir /b >dir.txt
You can then use regular word complete to complete filenames instead of the ctrl-x ctrl-f completion.

See :h ins-completion.

=== Change the definition of a word

Vim has a way of defining what is constituted as a word.
This is important when:

* Using commands such as ciw to change the word, delete the word, etc.
* Moving forwards and backwards by a word with w and b.
* When using regular expressions to perform substitutions that are more efficient if for example hypens and/or periods are considered part of the word instead of breaking two words.
+
This is important for use with DITA XML at Cepheid when needing to do massive substitutions.
For example, you may also want to include the filename extension in the definition of a word so the period to not break the word.

To include hyphens and periods in the definition of a word:

:set iskeyword+=\- 
:set iskeyword+=\.

To remove hyphens and periods from the definition of a word:

:set iskeyword-=\- 
:set iskeyword-=\.

For general prose, it is better to break words when there is a hyphen or a period.

=== Omni completion

:help new-omni-completion 

For specific language file types, "omni completion" is used.
Various programming languages are natively built into Vim, such as SQL, HTML, XML, CSS, JavaScript and PHP and will work out of the box.
Other languages such as C and PHP will also take advantage of a tags file created with a utility like cTags. 
I won't need cTags as I don't use these languages.

To use Omni completion, you have to add this to the vimrc to turn it on as it is not on by default.

set omnifunc=syntaxcomplete#Complete

=== AutoComplPop plugin

To reduce keystrokes, you can use the AutoComplPop plugin to automatically popup the options lists as you type.
This avoids having to type ctrl-n or ctrl-p or the mapped TAB key.

https://github.com/othree/vim-autocomplpop/blob/master/doc/acp.txt

In a text file or ascidoc file or other file type not recognized by Vim as a supported omni completion language, the plugin uses the basic ctrl-n/ctrl-p completion as indicated in the status line.

image::vim-keyword-completion.png[width=60%]

In an XML file, which is a supported omni completion language, the plugin uses the omni completion type.

image::vim-omni-completion.png[width=50%]

To toggle this behavior:

* :AcpEnable
* :AcpDisable

To switch to filename completion, just use the mapping <leader><Tab>.
This is very convenient and makes this plugin a possibility for use with DITA CMS.

The popup behavior can be slow.

There are a few things you can do to speed it up.

* Lower the timeoutlen and ttimeoutlen settings in the vimrc.
* Do not include the 'i' option and make it so that the popup doesn't appear until you have typed three characters with the following vimrc settings:

----
let g:acp_enableAtStartup = 1
let g:acp_completeOption = '.,w,b,u'
let g:acp_behaviorFileLength = 3
let g:acp_behaviorXmlOmniLength = 3
----

=== Optimizing completion for XML in a CMS

See xref:#writing-xml[]

== Defining what a word is

For use with Autocomplete, you can define a word to include additional characters.
This is useful for DITA conrefs that have GUIDs, .xml filenames, and # IDs.
It is set for only the active buffer.

:set iskeyword+=\-  (a word includes hyphens, which you need to insert-complete GUIDs and filenames)
:set iskeyword+=\.  (a word includes periods which you need to insert-complete filenames with extensions (.png, .xml))
:set iskeyword+=\#  (a word includes # for IDs but I think it's better to not do this)

This can also be set in the vimrc.

== Global patterns

:g/pattern/d - deletes all lines that include the pattern

:g/pattern/s/old/new/gc - Do a substitution in only those lines that match the pattern

== Collect lines matching a pattern

Uses the 'g' global command and 'v' global NOT command.

Either:

. :%g/pattern/y A - copy all lines matching the pattern to register a - using uppercase A ensures all lines are copied and not just the last line.
. :new newfile.txt
. "ap - to paste

Or,

. :g/pattern/
. F4

This one uses a mapping in the vimrc.

NOTE: Using the global command to collect lines is different from using vimgrep.
With vimgrep, the lines are truncated in the quickfix list so you can't copy out the whole line. In addition, there is information in the quickfix list lines other than the text of the line.

* %g/hobbit/m$ - moves lines in the document containg the word hobbit to the end of the document

The v command is the *inVerse* of g.
Therefore:

* %g/foo/d - delete all lines in the document that contain 'foo'
* %v/foo/d - delete all lines in the document that DO NOT contain 'foo' (v means NOT)
* %v/foo/m$ - move all lines that DO NOT contain 'foo' to the end of the document (v means NOT)
* :v/foo/ then F3 - copy all lines that DO NOT contain foo and paste them into a new buffer (v means NOT)
* :g/foo/j - join any line containing 'foo' to its subsequent line

== Format HTML

The most complete strategy for cleaning up an HTML file might be to:

. Filter it through pandoc (only if there is a lot of cruft in the code).
. Run Tidy to fix errors in the HTML and do some tidying.
. Run Prettier to do nice tidying.

Tidy will fix errors in HTML as well as format it although the formatting does not seem to be as nice as the formatting result of Prettier.
To use:

:tidyHTML

Prettier will format HTML with the line editor command but it will not fix errors in the code.
To use:

:Prettier

Prettier is NOT currently set up in the vimrc to automatically format HTML on save.

== Format CSS

Prettier is set to automatically format CSS on save using the following setting in the vimrc.

let g:prettier#autoformat_require_pragma = 0

See also xref:lintingcss[]

== Format XML

I am currently using :XMLlint.
Tidy can also tidy up XML with :tidyXML

[#lintingcss]
== Lint CSS

Currently using ALE for linting.
See the vimrc for more details.

To lint CSS:

. Open a file.
. Place stylelintrc.json file in the directory with the file
. <leader>cd to set the file as the working directory
. Run :ALELint.
. :lopen to see the list of errors.
. :lclose to close the list.

== Lint XML

To lint XML:

XMLlint is set up to automatically lint files.
Open the XML file and then open the location list :lopen.
Any errors will be marked in the margin.

To validate a DITA file per the command in the vimrc:
command! DITAvalid %!xmllint % --valid --noout

:DITAvalid

NOTE: The DITA file must be in the same folder as the DTD for the topic type eg concept.dtd.

== Linting HTML

To lint HTML:

* :Prettier
* :copen

== Use Git from within Vim

It is better to use GitHub client as this is linked to GitHub for easy push/pull without security codes and you can see the changes more easily.

.gv-vim commands
* :GV - browse the commits and view diffs (uses junegunn/gv.vim plugin)
* :GV! - browse commits and view diffs for only the current buffer

.Git Fugitive commands
* :G[it] - open a new buffer with a summary window like git status (uses vim-fugitive), press g? for options
* :q - closes the window (status window or any diff window)
* :Gdiff - open a new buffer in a vertical split to show the diff vs the last commit
* :Git diff - open a new horizontal buffer showing dirty files and unpushed and unpulled commits
* :Git blame - list commits and person responsible
* :Git log - open a new buffer showing the Git log
* :Gclog - opens the diff with the previous commit and opens a quickfix list with a list of commits that you can then use to open other diffs
* :Git push - push to the assigned remote
* s - stage the file
* u - unstage the file 
* U - unstage everything
* = - toggle an inline diff of the file under the cursor
* dv - invoke a :Gvdiffsplit on the file under the cursor
* o - open the file under the cursor in a new split
* p - open the file under the cursor in a preview window

To allow a Git repo push to the GitHub remote or pull from it, you need to use a personal access token.
To do this, you must clone the repo from GitHub to your local drive using the following syntax:

----
git clone https://mark-bez:

token

@github.com/mark-bez/

notes.git
----

I had to split it onto different lines to prevent GitHub from flagging it and disabling my token.

== Diff two buffers

Three ways to bring up windows to diff:

* :windo difft - diffs two buffers
* Open file1, then :diffsplit file2
* Win key vdiff file1 file2

To copy a difference from one split to the other:

* dp (or :diffput) - put, when the cursor is on the line to copy
* do (or :diffget) - get, when the cursor is on the line that is empty

Toggle vertican and horizontal windows:

* ctrl-K - change from vertical to horizontal diff split.
* ctrl-H - change from horizontal to vertical diff split.

[c - go to the next difference
]c - go to the previous difference

Export the diff to an HTML file:

:TOhtml | w ~/Desktop/diff.html

Note: It is TO and not To.

The first command generates the HTML.
The second command (after the pipe) writes it to the file.

== Marks

* mN - mark the cursor position and store it in N
* 'N - goto beginning of the line containing the mark stored in N
* `N - go to cursor position of the mark stored in N
* :marks - list all marks
* :delm N - delete mark stored in N
* :delm! - delete all marks
* :delm a-z - delete marks a-z
* :del abc - delete marks a, b, and c
* d'N - delete from the cursor to the beginning of the line containing marker N
* d`N - delete from the cursor to the line/column position of marker N

== Navigating back in Normal mode

* '' - return to the line where the cursor was before the last jump  (Two single quotes)
* `` - return to the cursor position before the last jump - undoes the jump (Two back ticks)
* `. - return to the last change in current buffer
* `" - return to the last exited current buffer
* `0 - go to the file other than this one that you last edited
* g; - places cursor at the last place an edit was made without undoing the edit, repeat to go back in history
* g, - repeat to go forward in the history of edits
* gi - return to the last position of cursor in insert mode
* ctrl-o - moves back to older jumps, including to a file that was just closed
* ctrl-i - moves forward in the jumplist

Using kshenoy/vim-signature to place marks in the sign column.
To stop showing marks in the sign column:
:SignatureToggle
There are also custom mappings for this plugin.

== Screen arrangements

:only - close all other split screens except the current one
:res +N or -N - change the height of a horizontal window by N lines
z{height] - change the height of a horizontal window to N lines
:vert res +N or -N - change the width of a vertical window by N columns
ctrl-w r - swap split windows

== Print a buffer

:hardcopy > file.txt

To print a PDF of a file, which is the only option for files other than AsciiDoc files:

:hardcopy > file.ps

This opens a dialog to convert to a PDF via a printer such as Microsoft or Adobe.
Preferably, select Adobe, change the settings, such as to landscape and 'paper' size.
To print Vim diff files, the colorscheme makes a difference to the output coloring.
So far, gruvbox with background=light works well.

== Lists

* q: or :ctrl-f - editable list of recent commands, select a command and press ENTER to issue
* :changes - shows the last 100 changes that can be undone
* :reg - shows the contents of the registers, also shown in a different format with Vim Sneak after pressing "
* :jumps - shows the history of where the cursor jumped for the current window; a jump is (1)Freely jumping around a file, such as :20, (2) Jumping based on the window size, such as M, (3) Text block jumps, such as ( and {
* :history - shows command history
* :oldfiles - default vim
* :undolist -
* :map - lists the characters that are mapped
* :Oldfiles - uses plugin to put oldfiles into the quickfix list
* :tabs - shows a list of the open tabs with their buffers - very useful

== Jumps

A jump is initiated by one of the following commands: '', `, G, /, ?, n, N, %, (, ), [[, ]], {, }, :s, :tag, L, M, H and the commands that start editing a new file.
Basically, jumping to marks, searching, brackets, screen positions.
The position of the cursor before the jump is remembered.
You can return to that position with the '' and `` command.

* :jumps
* ctrl-o - moves back to older jumps, including to a file that was just closed
* ctrl-i - moves forward in the jumplist

== Changes

Locations of edits are stored in the change list.

* :changes
* g; - places cursor at the last place an edit was made without undoing the edit, repeat to go back in history
* g, - repeat to go forward in the history of edits

== Find

* :find <TAB> to open files in the path of the *current file*
* :sfind to open it in a split window
* :vert sfind to open it in a vertical split window

These are different to :edit <TAB>, which opens files in the path of the current working directory

:find uses the path defined in :set path?
By default this is path=.,,

This means search relative to the directory of the current file AND the current directory.
This may result in too many hits and slow the search.

To search only relative to the directory of the current file, use:
:set path=.

To search in the current directory only use an empty string between two commas use:
:set path=,,

What if we wanted to search downward recursively through our project? 
It is common to open your text editor in your project root ( often denoted by a vcs file such as a .git folder ). 
To ensure that Vim finds all of our project files when we search for them, we use * and **. 
The asterisks represent wildcards, with * matching 0 or more characters and ** matching only directories. 
By setting your path to set path=.,,,**, you can ensure that Vim will search all our project files.

Can use wildcards such as :find *word* or **/*word

== Run a vimscript

. Create the vimscript file filename.vim
. Open the file you want to run the script on.
. :source filename.vim

== Registers

Registers are global to the session.
To see the contents of the registers:
:reg

* The unnamed register "" - text deleted with the "d", "c", "s", "x" commands or copied with the yank "y" command
* 10 numbered registers "0 to "9 -  text from yank and delete commands when *at least a whole line was changed*
* The small delete register "- text from commands that delete less than one line, such as with dw
* 26 named registers "a to "z or "A to "Z
* Three read-only registers ":, "., "% - can use them only with the "p", "P", and ":put" commands and with CTRL-R
* Alternate buffer register "#
* The expression register "=
* The selection and drop registers "*, "+ and "~
* The black hole register "_
* Last search pattern register "/

"<register>

For example:

* "ay - Copy to register a
* "ap - Paste from register a

The default register that yank copies to is ".

The previously yanked text is stored in registers 0-9.
To paste a previous undo, first identify the register it is saved in, then "Np such as "4p

== Copying and pasting text to the commandline

This is yank followed by ctrl-r on the commandline.

. Yank the string (to the default unnamed register)
. In the commandline:
+
----
:<Ctrl r>
----
+
This adds the " character which means it's waiting for a register number/character.

. Type " to paste the yanked string from the unnamed register.

This is
:ctrl-r "

== Autocomplete path in commandline

ctrl-x ctrl-f

== Generate a PDF file from an Asciidoc file

Uses https://github.com/habamax/vim-asciidoctor plugin.

In addition to asciidoctor, you must have asciidoctor-pdf, asciidoctor-diagram, and asciidoctor-rouge extensions installed for HTML and DOCX file creation.

* $ gem install asciidoctor-pdf
* $ gem install asciidoctor-diagram
* $ gem install asciidoctor-rouge

Type the following *quickly*:

* <leader>oo - open the Asciidoc file in a browser
* <leader>ch the <ENTER> - generate an HTML file
* <leader>oh then <ENTER> - open the previously generated HTML file
* <leader>cp then <ENTER> - generate a PDF file
* <leader>op then <ENTER> - open the previously generated PDF file
* <leader>cx then <ENTER> - print to .docx
* <leader>ox - open the previously generated .docx file

NOTE: Make sure the cursor is not on a character with <leader>cp or ch.
It will otherwise clash with switching the letter.

After generating, use :bd to close the window and return to the document.

== Code folding

* zo or spacebar - open a fold 
* zO - open a fold and all its subfolds 
* zc - close a fold 
* zC - close a fold and all its subfolds 
* za - toggle a fold 
* zr - open a fold by one level 
* zm - close a fold by one level 
* zR - open all folds 
* zM - close folds <leader>x - initiate code folding in XML files 
* zj - move cursor down one fold
* zk - move cursor up one fold

If the cold folding doesn't work for a section, the fold may have been deleted with zd.
Use :e to reload the file and refold.

The color of the folds is set in the vimrc to look great with Gruvbox dark with:

highlight Folded guifg=goldenrod2

To fold HTML or XML after pretty printing:

:set foldmethod=indent

To fold AsciiDoc with the AsciiDoc plugins I use, several different fold methods seem to work:

* :set foldmethod=expr
* :set foldmethod=manual

== Copy filepath

Copies to unnamed register "

* cp - copies filename
* cP - copies filepath
* p to paste

== Pattern search

:h Q_pa

            matches any single character  \.
                   matches start of line  ^
                           matches <EOL>  $
                   matches start of word  \<
                     matches end of word  \>
    matches a single char from the range  \[a-z]
  matches a single char not in the range  \[^a-z]
         matches a white space character  \s
     matches a non-white space character  \S
                           matches <Esc>  \e
                           matches <Tab>  \t
                            matches <CR>  \r
            group a pattern into an atom  \(\
    matches 2 to 5 of the preceding atom  \{2,5}
 matches 0 or more of the preceding atom  \*
 matches 1 or more of the preceding atom  \+
    matches 0 or 1 of the preceding atom  \=
              separates two alternatives  \|

== End-of-line characters

\r is the carriage return characters.

\n is the newline character.

The Windows end-of-line sequence is:

\r\n

== vimgrep to list lines that match a pattern

* :vimgrep //g - use the current search pattern for vimgrep
* :vimgrep /{paste in current search pattern with ctrl-r/}
* First search with / and then :vimgrep //g % to do the vimgrep. This highlights all the matches.
* :vimgrep word % - only finds the first match in each file
* :vimgrep "words with spaces" %
* :vimgrep /words with spaces/ %
* :vimgrep word /g% - finds all matches in each file
* :vimgrep /word/g ## - acts on arglist
* :vimgrep word gj% %
* g = global in the file (lists each instance on a separate quickfix line if line has multiple matches)
* j = do not automatically jump to the first match
* %(with no space) = include in the listing which file you're on (eg 2 of 5) (the first %)
* % = search the current buffer (the second %)
* :vimgrep /word/g git ls-files - search all tracked files in Git project
* :vim - same as vimgrep
* :copen
* :cclose
* :vimgrep word **/*.txt - search within folders
* :cn and :cp to navigate quickfix list
* :cc n - navigate to nth item in quickfix list
* :colder and cnewer - view previous quickfix lists
* :vimgrepa - appends new search to bottom of current quickfix list

For location list, specific to the window, instead of the global quickfix list:

* :lvimgrep word % - populates current window's location list instead of quickfix list allowing multiple across file searches at once.
* :lopen

vimgrep is for searching and listing not collecting lines of text.
It truncates the lines in the quickfix list.

The default scope of the search is the working directory.

* :vimgrep word gj% *.txt
* :vimgrep /pattern/g **/*.txt
* :vimgrep word g ##

* *.txt = search only in text files in the current folder
* **/*.txt = search in text files in the current folder and subfolders
* ## = searches the set of files in the arglist

== Editing files in ZIP files

. vim file.zip
. Choose the file you want to edit, change what you want, and exit with :x
. If vim responds with "Cannot make changes, 'modifiable' is off", just run :set modifiable or :set ma.

== Sessions

* :mks - creates a file called Session.vim in the current working directory; you can have a different Session.vim file for every project directory
* :mks! - overwrites the default Session.vim
* :mks mysesion.vim - creates a file called mysession.vim in the current working directory or other path
* gvim -S filepath/filename.vim - opens gVim and loads the saved session
* :so filepath/filename.vim to switch to a different session

== Using the arglist

During a working session, the buffers list becomes messy.
An arglist can provide a stable subset of files that improves navigation.

* :args to list the files in the arglist
* :n to move to the next file in the list
* :first to move to the first
* :last to move to the last
* :rew same as :last
* :argadd file - add a file to the args list
* :argdel file - delete a file from the args list

== Calculations

From insert mode:
ctrl-r =
enter the calculation and press ENTER.

If you have already typed the calculation into the buffer:

. Yank only the expression without the equals sign into the unnamed register
. shift-a to enter insert mode at the end of the line
. <ctrl-r>= to enter the expression register
. <ctrl-r>" to paste the yanked text from the unnamed register (that is the shift key with ")
<enter> to perform the calculation and insert the result

5*10=50

5+5=10

== Digraphs

Keyboards don't have enough keys to show all characters that can be entered into a document.
Additional characters are entered via codes, such as ASCII and Unicode.
Different operating systems and application software have different ways for entering these codes.
Not all fonts support all Unicode characters.
Windows has the Character Map for entering these extended character codes.
Windows also supports keysequence input of Unicode codes with Alt + nnnn(n).

On Windows, to enter Unicode 2014, type `Alt +2014`. 
You must use the numpad key for typing the + and 2014.

Applications often have their own equivalents built in for selecting extended characters.
After entering the character, the application often converts the code to the 'glyph' character.
Character glyphs can also be copied and pasted so another way to enter them is to copy the character from the internet.
For entering extended characters in XML, you can also use &#nn; (decimal form) or &Xxnn; (hexadecimal form).
There are two ways to enter extended characters in Vim.

=== Entry with Digraphs
* Cheatsheet 1: https://devhints.io/vim-digraphs
* Cheatsheet 2: https://www.cs.auckland.ac.nz/references/gnu/vim/digraph.html

Digraphs use two-character codes.
To see the codes:

:h digraph-table

:h dig[raph]

To enter a digraph, in insert mode:
ctrl-k character1 character2

To list digraphs:
:dig

щ
ざ

=== Direct entry of the Unicode code

In insert mode, type:

. ctrl-v
. u
. The four or five digit unicode with the regular keyboard or numpad

ctrl-v u2020 gives this:
†

ctrl-v u03c0 gives this:
π

To see the character code in the statusline:
ga

:help i_CTRL-V_digit

For substitutions:

:%s/<Ctrl-v>u200e//g

== Regular expressions
To set up a regex:

. Use the search to identify the expression that matches what you want (/)
. Build the substitution expression with an empty match, which defaults to the last search pattern.

For example:

/pattern

:%s//replacement/g

You can also use ctrl-r / to paste in the previous search pattern.

To see which characters need to be escaped, see:

* h: magic
* h:ordinary-atom

Magic mode is the default mode for Vim regular expressions.
The characters that I typically need to backslash with Magic mode are:

* ( When making a subexpression group
* ) When making a subexpression group
* \ For literal backslashes in file paths
* . For literal dots in filenames
* ^ Literal ^
* $ Literal $
* # Literal # 

IMPORTANT: The following pattern items also need to be escaped with a backslash:

* + One or more
* ? Zero or one
* * Zero or more
* { } An interval
* {n} Exactly that number 
* {n,} At least n
* @>  Matches the whole pattern in the replace
* @! Requires NO match
* _. Any single character or newline (great option!)
* < Beginning of word
* > End of word
* %^ Beginning of file
* %$ End of file
* s Whitespace character
* S Non-whitespace character
* d Digit character
* D non-digit character
* w Word character
* W Non-word character
* a Alphabetic character
* l Lowercase character
* u uppercase character
* r carriage return <CR>
* n newline
* 1 First group in the pattern
* 2 Second group in the pattern
* c Ignore case (when ignorecase option is not set)
* C Match case (when ignorecase option is not set)

Vim does not support character classes inside groups, so for example:

[\w] does not work.

You have to use POSIX instead like this:

[[:space:]]

So, to replace any character between XML tags with an X use this:

%s/<p>[[:space:][:alnum:]]<\/p>/<p>X<\/p>/g

[#writing-xml]
== Writing XML

This setup is for XML files stored in a CMS where file addressing is with GUID filenames instead of file paths and the XML files and image files are all in one folder.
Only keywords in the file buffers will be available for omni completion for the XML language.
Only files in the present working directory and subfolders will be available for filename completion.

* Place the set of files you will be working on in their own folder.
* Open one of the XML files in a new Vim instance
* Set the present working directory to the folder the file is in.
* :badd dita-elements.txt to load the buffer but keep it hidden - has a subset of the DITA elements I may use.
* :badd <warehouse files> as needed to load files I might conref to as needed
* Create a text file of GUIDS (guid.txt) and :badd to load the buffer
* Ensure AutoComplPop is enabled :AcpEnable (should be on by default)

* To start a new file, :new filename_guid.xml, then <leader>dt or dc or dnt, or dnc to add the basic structure. Can also use enew filename to replace the currently viewed buffer in the window.
* To type the XML tags, use the xml.vim filetype plugin in combination with the mapping to automatically close XML/HTML tags in the vimrc.
* The XML file tag completion behavior uses the vimrc mapping `inoremap ><Tab> ><Esc>F<lyt>o</<C-r>"><Esc>O<Space>`
* The omni completion popup via AcpEnable draws on the content and fielnames of the open buffers. Press <ENTER> to add the highlighted word and <TAB> to cycle through the list.
* To use filename completion, type <leader><TAB> and completion will switch from omni completion to filename completion, drawing on the files in the present working directory.
* Automatic typo correction is enabled via vim-abolish/vim-correction plugins and the vimrc setting that adds XML files for use with this plugin.
* Make sure the iskeyword setting in the vimrc includes the hyphens and period so a GUID and filename extension are recognized a word for autocompletion (set iskeyword+=\-)

* To add the GUID part of a link in a way that deletes the GUID so you don't reuse it:
** Open the GUID text file in a vsplit :vsp guid.txt
** Position the cursor at the correct location in the topic.
** daW to delete the GUID
** ctrl-h to return to the topic and 'p' to put.

* To add a link:
* `<conref/xref/image href="..` then <leader><Tab> to complete the filename.
* For a conref, the syntax is <filename.xml>#<warehouse-topic-id>/<conref-id>  The two id's can be completed if the warehouse file buffer is loaded.

If you don't want to use AutoComplPop, you can disable it with :AcpDisable.
Then, use <TAB> to do standard word completion and <leader><Tab> to do filename completion.

To fold XML or HTML after pretty printing:
:set foldmethod=indent

== Formatting columns

=== Method 1 - when the text of each column is equal in width

. Add a separator before the start of each column except the first column, such as a comma.
+
----
one,two
one,two
one,two
one,two
----

. Visually select the lines with shift-v.
. Add spaces before and after the equals sign with substitution, such as  s/,/            ,/g 
+
----
one          ,two
one          ,two
one          ,two
one          ,two
----

. Use block visual select to delete the separator character (comma).

=== Method 2 - when the text of each column is **un**equal in width

Starting with this example:

----
hobbits,column2
elves,column2
dinosaurs,column2
rumplestiltskin,column2
----

. Perform the steps in method 1 to create two or more columns.

----
hobbits              ,column2
elves              ,column2
dinosaurs              ,column2
rumplestiltskin              ,column2
----
+
Note that the second column is uneven.

. In the first row, place your cursor in the screen column position you want to align the text of the second column to.
+ 
In this example it might be screen column 20. 

. Using ctrl-v, visually select downwards through each row. 
. Press << to "unindent" the right hand side of each equation towards the column you selected.
+
----
hobbits            ,column2
elves              ,column2
dinosaurs            ,column2
rumplestiltskin            ,column2
----

. Press . as many times as you need to to align the columns.

----
hobbits            ,column2
elves              ,column2
dinosaurs          ,column2
rumplestiltskin    ,column2
----

. Use block visual select to delete the separator character (comma).

=== Method 3

Use junegunn/vim-easy-align or other plugin

== Vim Help

* :helpgrep {word} - search Vim help
* :help index - list of all commands
* :help normal - list of normal mode commands
* :help insert - list of insert mode commands
* :help visual - list of visual mode commands

== To do next

* Add more headings to vimrc for better organization

== Best cheatsheets:

* http://www.zzapper.co.uk/vimtips.html
* https://devhints.io/vim
* https://blog.carbonfive.com/vim-text-objects-the-definitive-guide/


This is a test.
